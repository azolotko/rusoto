<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `DynamoDBClient` struct in crate `rusoto`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, DynamoDBClient">

    <title>rusoto::dynamodb::DynamoDBClient - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../index.html'>rusoto</a>::<wbr><a href='index.html'>dynamodb</a></p><script>window.sidebarCurrent = {name: 'DynamoDBClient', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>rusoto</a>::<wbr><a href='index.html'>dynamodb</a>::<wbr><a class='struct' href=''>DynamoDBClient</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-9324' class='srclink' href='../../src/rusoto///Users/jimmy/Code/rusoto/target/debug/build/rusoto-27b53b229e74877b/out/dynamodb.rs.html#17947-17950' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct DynamoDBClient&lt;'a&gt; {
    // some fields omitted
}</pre><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl&lt;'a&gt; <a class='struct' href='../../rusoto/dynamodb/struct.DynamoDBClient.html' title='rusoto::dynamodb::DynamoDBClient'>DynamoDBClient</a>&lt;'a&gt;</code></h3><div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>&lt;P: <a class='trait' href='../../rusoto/credentials/trait.AWSCredentialsProvider.html' title='rusoto::credentials::AWSCredentialsProvider'>AWSCredentialsProvider</a> + 'a&gt;(creds: P, region: &amp;'a <a class='enum' href='../../rusoto/regions/enum.Region.html' title='rusoto::regions::Region'>Region</a>) -&gt; <a class='struct' href='../../rusoto/dynamodb/struct.DynamoDBClient.html' title='rusoto::dynamodb::DynamoDBClient'>DynamoDBClient</a>&lt;'a&gt;</code></h4>
<h4 id='method.update_table' class='method'><code>fn <a href='#method.update_table' class='fnname'>update_table</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.UpdateTableInput.html' title='rusoto::dynamodb::UpdateTableInput'>UpdateTableInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.UpdateTableOutput.html' title='rusoto::dynamodb::UpdateTableOutput'>UpdateTableOutput</a>&gt;</code></h4>
<div class='docblock'><p>Modifies the provisioned throughput settings, global secondary indexes, or
DynamoDB Streams settings for a given table.
You can only perform one of the following operations at once:
  * Modify the provisioned throughput settings of the table.
  * Enable or disable Streams on the table.
  * Remove a global secondary index from the table.
  * Create a new global secondary index on the table. Once the index begins backfilling, you can use <em>UpdateTable</em> to perform other operations.
<em>UpdateTable</em> is an asynchronous operation; while it is executing, the table
status changes from <code>ACTIVE</code> to <code>UPDATING</code>. While it is <code>UPDATING</code>, you cannot
issue another <em>UpdateTable</em> request. When the table returns to the <code>ACTIVE</code>
state, the <em>UpdateTable</em> operation is complete.</p>
</div><h4 id='method.delete_table' class='method'><code>fn <a href='#method.delete_table' class='fnname'>delete_table</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.DeleteTableInput.html' title='rusoto::dynamodb::DeleteTableInput'>DeleteTableInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.DeleteTableOutput.html' title='rusoto::dynamodb::DeleteTableOutput'>DeleteTableOutput</a>&gt;</code></h4>
<div class='docblock'><p>The <em>DeleteTable</em> operation deletes a table and all of its items. After a
<em>DeleteTable</em> request, the specified table is in the <code>DELETING</code> state until
DynamoDB completes the deletion. If the table is in the <code>ACTIVE</code> state, you
can delete it. If a table is in <code>CREATING</code> or <code>UPDATING</code> states, then DynamoDB
returns a <em>ResourceInUseException</em>. If the specified table does not exist,
DynamoDB returns a <em>ResourceNotFoundException</em>. If table is already in the
<code>DELETING</code> state, no error is returned.
DynamoDB might continue to accept data read and write operations, such as
<em>GetItem</em> and <em>PutItem</em>, on a table in the <code>DELETING</code> state until the table
deletion is complete.
When you delete a table, any indexes on that table are also deleted.
If you have DynamoDB Streams enabled on the table, then the corresponding
stream on that table goes into the <code>DISABLED</code> state, and the stream is
automatically deleted after 24 hours.
Use the <em>DescribeTable</em> API to check the status of the table.</p>
</div><h4 id='method.batch_get_item' class='method'><code>fn <a href='#method.batch_get_item' class='fnname'>batch_get_item</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.BatchGetItemInput.html' title='rusoto::dynamodb::BatchGetItemInput'>BatchGetItemInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.BatchGetItemOutput.html' title='rusoto::dynamodb::BatchGetItemOutput'>BatchGetItemOutput</a>&gt;</code></h4>
<div class='docblock'><p>The <em>BatchGetItem</em> operation returns the attributes of one or more items from
one or more tables. You identify requested items by primary key.
A single operation can retrieve up to 16 MB of data, which can contain as many
as 100 items. <em>BatchGetItem</em> will return a partial result if the response size
limit is exceeded, the table&#39;s provisioned throughput is exceeded, or an
internal processing failure occurs. If a partial result is returned, the
operation returns a value for <em>UnprocessedKeys</em>. You can use this value to
retry the operation starting with the next item to get.
If you request more than 100 items <em>BatchGetItem</em> will return a
<em>ValidationException</em> with the message &quot;Too many items requested for the
BatchGetItem call&quot;.
For example, if you ask to retrieve 100 items, but each individual item is 300
KB in size, the system returns 52 items (so as not to exceed the 16 MB limit).
It also returns an appropriate <em>UnprocessedKeys</em> value so you can get the next
page of results. If desired, your application can include its own logic to
assemble the pages of results into one data set.
If <em>none</em> of the items can be processed due to insufficient provisioned
throughput on all of the tables in the request, then <em>BatchGetItem</em> will
return a <em>ProvisionedThroughputExceededException</em>. If <em>at least one</em> of the
items is successfully processed, then <em>BatchGetItem</em> completes successfully,
while returning the keys of the unread items in <em>UnprocessedKeys</em>.
If DynamoDB returns any unprocessed items, you should retry the batch
operation on those items. However, <em>we strongly recommend that you use an
exponential backoff algorithm</em>. If you retry the batch operation immediately,
the underlying read or write requests can still fail due to throttling on the
individual tables. If you delay the batch operation using exponential backoff,
the individual requests in the batch are much more likely to succeed.
For more information, see <a href="http://docs.aw%0As.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#BatchOper%0Aations">Batch Operations and Error Handling</a> in the <em>Amazon DynamoDB Developer Guide</em>.
By default, <em>BatchGetItem</em> performs eventually consistent reads on every table
in the request. If you want strongly consistent reads instead, you can set
<em>ConsistentRead</em> to <code>true</code> for any or all tables.
In order to minimize response latency, <em>BatchGetItem</em> retrieves items in
parallel.
When designing your application, keep in mind that DynamoDB does not return
attributes in any particular order. To help parse the response by item,
include the primary key values for the items in your request in the
<em>AttributesToGet</em> parameter.
If a requested item does not exist, it is not returned in the result. Requests
for nonexistent items consume the minimum read capacity units according to the
type of read. For more information, see [Capacity Units Calculations](http://d
ocs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html</p>

<h1 id='capacityunitcalculations-in-the-amazon-dynamodb-developer-guide' class='section-header'><a href='#capacityunitcalculations-in-the-amazon-dynamodb-developer-guide'>CapacityUnitCalculations) in the <em>Amazon DynamoDB Developer Guide</em>.</a></h1></div><h4 id='method.scan' class='method'><code>fn <a href='#method.scan' class='fnname'>scan</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.ScanInput.html' title='rusoto::dynamodb::ScanInput'>ScanInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.ScanOutput.html' title='rusoto::dynamodb::ScanOutput'>ScanOutput</a>&gt;</code></h4>
<div class='docblock'><p>The <em>Scan</em> operation returns one or more items and item attributes by
accessing every item in a table or a secondary index. To have DynamoDB return
fewer items, you can provide a <em>ScanFilter</em> operation.
If the total number of scanned items exceeds the maximum data set size limit
of 1 MB, the scan stops and results are returned to the user as a
<em>LastEvaluatedKey</em> value to continue the scan in a subsequent operation. The
results also include the number of items exceeding the limit. A scan can
result in no table data meeting the filter criteria.
By default, <em>Scan</em> operations proceed sequentially; however, for faster
performance on a large table or secondary index, applications can request a
parallel <em>Scan</em> operation by providing the <em>Segment</em> and <em>TotalSegments</em>
parameters. For more information, see <a href="http://docs.aws.amazon.c%0Aom/amazondynamodb/latest/developerguide/QueryAndScan.html#QueryAndScanParallel%0AScan">Parallel Scan</a> in the <em>Amazon DynamoDB Developer Guide</em>.
By default, <em>Scan</em> uses eventually consistent reads when acessing the data in
the table or local secondary index. However, you can use strongly consistent
reads instead by setting the <em>ConsistentRead</em> parameter to <em>true</em>.</p>
</div><h4 id='method.describe_table' class='method'><code>fn <a href='#method.describe_table' class='fnname'>describe_table</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.DescribeTableInput.html' title='rusoto::dynamodb::DescribeTableInput'>DescribeTableInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.DescribeTableOutput.html' title='rusoto::dynamodb::DescribeTableOutput'>DescribeTableOutput</a>&gt;</code></h4>
<div class='docblock'><p>Returns information about the table, including the current status of the
table, when it was created, the primary key schema, and any indexes on the
table.
If you issue a DescribeTable request immediately after a CreateTable request,
DynamoDB might return a ResourceNotFoundException. This is because
DescribeTable uses an eventually consistent query, and the metadata for your
table might not be available at that moment. Wait for a few seconds, and then
try the DescribeTable request again.</p>
</div><h4 id='method.batch_write_item' class='method'><code>fn <a href='#method.batch_write_item' class='fnname'>batch_write_item</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.BatchWriteItemInput.html' title='rusoto::dynamodb::BatchWriteItemInput'>BatchWriteItemInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.BatchWriteItemOutput.html' title='rusoto::dynamodb::BatchWriteItemOutput'>BatchWriteItemOutput</a>&gt;</code></h4>
<div class='docblock'><p>The <em>BatchWriteItem</em> operation puts or deletes multiple items in one or more
tables. A single call to <em>BatchWriteItem</em> can write up to 16 MB of data, which
can comprise as many as 25 put or delete requests. Individual items to be
written can be as large as 400 KB.
<em>BatchWriteItem</em> cannot update items. To update items, use the <em>UpdateItem</em>
API.
The individual <em>PutItem</em> and <em>DeleteItem</em> operations specified in
<em>BatchWriteItem</em> are atomic; however <em>BatchWriteItem</em> as a whole is not. If
any requested operations fail because the table&#39;s provisioned throughput is
exceeded or an internal processing failure occurs, the failed operations are
returned in the <em>UnprocessedItems</em> response parameter. You can investigate and
optionally resend the requests. Typically, you would call <em>BatchWriteItem</em> in
a loop. Each iteration would check for unprocessed items and submit a new
<em>BatchWriteItem</em> request with those unprocessed items until all items have
been processed.
Note that if <em>none</em> of the items can be processed due to insufficient
provisioned throughput on all of the tables in the request, then
<em>BatchWriteItem</em> will return a <em>ProvisionedThroughputExceededException</em>.
If DynamoDB returns any unprocessed items, you should retry the batch
operation on those items. However, <em>we strongly recommend that you use an
exponential backoff algorithm</em>. If you retry the batch operation immediately,
the underlying read or write requests can still fail due to throttling on the
individual tables. If you delay the batch operation using exponential backoff,
the individual requests in the batch are much more likely to succeed.
For more information, see <a href="http://docs.aw%0As.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#BatchOper%0Aations">Batch Operations and Error Handling</a> in the <em>Amazon DynamoDB Developer Guide</em>.
With <em>BatchWriteItem</em>, you can efficiently write or delete large amounts of
data, such as from Amazon Elastic MapReduce (EMR), or copy data from another
database into DynamoDB. In order to improve performance with these large-scale
operations, <em>BatchWriteItem</em> does not behave in the same way as individual
<em>PutItem</em> and <em>DeleteItem</em> calls would. For example, you cannot specify
conditions on individual put and delete requests, and <em>BatchWriteItem</em> does
not return deleted items in the response.
If you use a programming language that supports concurrency, you can use
threads to write items in parallel. Your application must include the
necessary logic to manage the threads. With languages that don&#39;t support
threading, you must update or delete the specified items one at a time. In
both situations, <em>BatchWriteItem</em> provides an alternative where the API
performs the specified put and delete operations in parallel, giving you the
power of the thread pool approach without having to introduce complexity into
your application.
Parallel processing reduces latency, but each specified put and delete request
consumes the same number of write capacity units whether it is processed in
parallel or not. Delete operations on nonexistent items consume one write
capacity unit.
If one or more of the following is true, DynamoDB rejects the entire batch
write operation:
  * One or more tables specified in the <em>BatchWriteItem</em> request does not exist.
  * Primary key attributes specified on an item in the request do not match those in the corresponding table&#39;s primary key schema.
  * You try to perform multiple operations on the same item in the same <em>BatchWriteItem</em> request. For example, you cannot put and delete the same item in the same <em>BatchWriteItem</em> request. 
  * There are more than 25 requests in the batch.
  * Any individual item in a batch exceeds 400 KB.
  * The total request size exceeds 16 MB.</p>
</div><h4 id='method.create_table' class='method'><code>fn <a href='#method.create_table' class='fnname'>create_table</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.CreateTableInput.html' title='rusoto::dynamodb::CreateTableInput'>CreateTableInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.CreateTableOutput.html' title='rusoto::dynamodb::CreateTableOutput'>CreateTableOutput</a>&gt;</code></h4>
<div class='docblock'><p>The <em>CreateTable</em> operation adds a new table to your account. In an AWS
account, table names must be unique within each region. That is, you can have
two tables with same name if you create the tables in different regions.
<em>CreateTable</em> is an asynchronous operation. Upon receiving a <em>CreateTable</em>
request, DynamoDB immediately returns a response with a <em>TableStatus</em> of
<code>CREATING</code>. After the table is created, DynamoDB sets the <em>TableStatus</em> to
<code>ACTIVE</code>. You can perform read and write operations only on an <code>ACTIVE</code> table.
You can optionally define secondary indexes on the new table, as part of the
<em>CreateTable</em> operation. If you want to create multiple tables with secondary
indexes on them, you must create the tables sequentially. Only one table with
secondary indexes can be in the <code>CREATING</code> state at any given time.
You can use the <em>DescribeTable</em> API to check the table status.</p>
</div><h4 id='method.list_tables' class='method'><code>fn <a href='#method.list_tables' class='fnname'>list_tables</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.ListTablesInput.html' title='rusoto::dynamodb::ListTablesInput'>ListTablesInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.ListTablesOutput.html' title='rusoto::dynamodb::ListTablesOutput'>ListTablesOutput</a>&gt;</code></h4>
<div class='docblock'><p>Returns an array of table names associated with the current account and
endpoint. The output from <em>ListTables</em> is paginated, with each page returning
a maximum of 100 table names.</p>
</div><h4 id='method.get_item' class='method'><code>fn <a href='#method.get_item' class='fnname'>get_item</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.GetItemInput.html' title='rusoto::dynamodb::GetItemInput'>GetItemInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.GetItemOutput.html' title='rusoto::dynamodb::GetItemOutput'>GetItemOutput</a>&gt;</code></h4>
<div class='docblock'><p>The <em>GetItem</em> operation returns a set of attributes for the item with the
given primary key. If there is no matching item, <em>GetItem</em> does not return any
data.
<em>GetItem</em> provides an eventually consistent read by default. If your
application requires a strongly consistent read, set <em>ConsistentRead</em> to
<code>true</code>. Although a strongly consistent read might take more time than an
eventually consistent read, it always returns the last updated value.</p>
</div><h4 id='method.query' class='method'><code>fn <a href='#method.query' class='fnname'>query</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.QueryInput.html' title='rusoto::dynamodb::QueryInput'>QueryInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.QueryOutput.html' title='rusoto::dynamodb::QueryOutput'>QueryOutput</a>&gt;</code></h4>
<div class='docblock'><p>A <em>Query</em> operation uses the primary key of a table or a secondary index to
directly access items from that table or index.
Use the <em>KeyConditionExpression</em> parameter to provide a specific hash key
value. The <em>Query</em> operation will return all of the items from the table or
index with that hash key value. You can optionally narrow the scope of the
<em>Query</em> operation by specifying a range key value and a comparison operator in
<em>KeyConditionExpression</em>. You can use the <em>ScanIndexForward</em> parameter to get
results in forward or reverse order, by range key or by index key.
Queries that do not return results consume the minimum number of read capacity
units for that type of read operation.
If the total number of items meeting the query criteria exceeds the result set
size limit of 1 MB, the query stops and results are returned to the user with
the <em>LastEvaluatedKey</em> element to continue the query in a subsequent
operation. Unlike a <em>Scan</em> operation, a <em>Query</em> operation never returns both
an empty result set and a <em>LastEvaluatedKey</em> value. <em>LastEvaluatedKey</em> is only
provided if the results exceed 1 MB, or if you have used the <em>Limit</em>
parameter.
You can query a table, a local secondary index, or a global secondary index.
For a query on a table or on a local secondary index, you can set the
<em>ConsistentRead</em> parameter to <code>true</code> and obtain a strongly consistent result.
Global secondary indexes support eventually consistent reads only, so do not
specify <em>ConsistentRead</em> when querying a global secondary index.</p>
</div><h4 id='method.put_item' class='method'><code>fn <a href='#method.put_item' class='fnname'>put_item</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.PutItemInput.html' title='rusoto::dynamodb::PutItemInput'>PutItemInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.PutItemOutput.html' title='rusoto::dynamodb::PutItemOutput'>PutItemOutput</a>&gt;</code></h4>
<div class='docblock'><p>Creates a new item, or replaces an old item with a new item. If an item that
has the same primary key as the new item already exists in the specified
table, the new item completely replaces the existing item. You can perform a
conditional put operation (add a new item if one with the specified primary
key doesn&#39;t exist), or replace an existing item if it has certain attribute
values.
In addition to putting an item, you can also return the item&#39;s attribute
values in the same operation, using the <em>ReturnValues</em> parameter.
When you add an item, the primary key attribute(s) are the only required
attributes. Attribute values cannot be null. String and Binary type attributes
must have lengths greater than zero. Set type attributes cannot be empty.
Requests with empty values will be rejected with a <em>ValidationException</em>
exception.
You can request that <em>PutItem</em> return either a copy of the original item
(before the update) or a copy of the updated item (after the update). For more
information, see the <em>ReturnValues</em> description below.
To prevent a new item from replacing an existing item, use a conditional put
operation with <em>ComparisonOperator</em> set to <code>NULL</code> for the primary key
attribute, or attributes.
For more information about using this API, see <a href="http://doc%0As.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html">Working with Items</a>
in the <em>Amazon DynamoDB Developer Guide</em>.</p>
</div><h4 id='method.update_item' class='method'><code>fn <a href='#method.update_item' class='fnname'>update_item</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.UpdateItemInput.html' title='rusoto::dynamodb::UpdateItemInput'>UpdateItemInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.UpdateItemOutput.html' title='rusoto::dynamodb::UpdateItemOutput'>UpdateItemOutput</a>&gt;</code></h4>
<div class='docblock'><p>Edits an existing item&#39;s attributes, or adds a new item to the table if it
does not already exist. You can put, delete, or add attribute values. You can
also perform a conditional update on an existing item (insert a new attribute
name-value pair if it doesn&#39;t exist, or replace an existing name-value pair if
it has certain expected attribute values). If conditions are specified and the
item does not exist, then the operation fails and a new item is not created.
You can also return the item&#39;s attribute values in the same <em>UpdateItem</em>
operation using the <em>ReturnValues</em> parameter.</p>
</div><h4 id='method.delete_item' class='method'><code>fn <a href='#method.delete_item' class='fnname'>delete_item</a>(&amp;mut self, input: &amp;<a class='struct' href='../../rusoto/dynamodb/struct.DeleteItemInput.html' title='rusoto::dynamodb::DeleteItemInput'>DeleteItemInput</a>) -&gt; <a class='type' href='../../rusoto/dynamodb/type.Result.html' title='rusoto::dynamodb::Result'>Result</a>&lt;<a class='struct' href='../../rusoto/dynamodb/struct.DeleteItemOutput.html' title='rusoto::dynamodb::DeleteItemOutput'>DeleteItemOutput</a>&gt;</code></h4>
<div class='docblock'><p>Deletes a single item in a table by primary key. You can perform a conditional
delete operation that deletes the item if it exists, or if it has an expected
attribute value.
In addition to deleting an item, you can also return the item&#39;s attribute
values in the same operation, using the <em>ReturnValues</em> parameter.
Unless you specify conditions, the <em>DeleteItem</em> is an idempotent operation;
running it multiple times on the same item or attribute does <em>not</em> result in
an error response.
Conditional deletes are useful for deleting items only if specific conditions
are met. If those conditions are met, DynamoDB performs the delete. Otherwise,
the item is not deleted.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "rusoto";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script defer src="../../search-index.js"></script>
</body>
</html>